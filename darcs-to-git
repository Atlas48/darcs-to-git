#!/usr/bin/env ruby
##
## Author: Steve Purcell, http://www.sanityinc.com/
## Obtain the latest version of this software here: http://git.sanityinc.com/
##

# TODO: import parallel darcs repos as git branches, identifying branch points


require 'ostruct'
require 'rexml/document'

ENV['TZ'] = 'GMT0'

SRCREPO = ARGV[0]
if [nil, '--help', '-h'].include?(SRCREPO)
  STDERR.write("usage: darcs-to-git DARCSREPO\n\nRun this in an empty directory when making an initial bulk conversion.\n")
  exit(1)
end

def run(*args)
  puts "Running: #{args.inspect}"
  system(*args) || raise("Failed to run: #{args.inspect}")
end

def output_of(*args)
  puts "Running: #{args.inspect}"
  output = IO.popen(args.map {|a| "'#{a}'"}.join(' '), 'r') { |p| p.read }
  if $?.exitstatus == 0
    return output
  else
    raise "Failed to run: #{args.inspect}"
  end
end


class DarcsPatch
  attr_accessor :source_repo, :author, :date, :inverted, :identifier, :name, :is_tag, :git_tag_name, :comment
  attr_reader :author_name, :author_email

  def initialize(source_repo, patch_xml)
    self.source_repo = source_repo
    self.author = patch_xml.attribute('author').value
    self.date = darcs_date_to_git_date(patch_xml.attribute('date').to_s)
    self.inverted = (patch_xml.attribute('inverted').to_s == 'True')
    self.identifier = patch_xml.attribute('hash').to_s
    self.name = patch_xml.get_elements('name').first.get_text.value rescue 'Unnamed patch'
    self.comment = patch_xml.get_elements('comment').first.get_text.value rescue nil
    if (self.is_tag = (self.name =~ /^TAG (.*)/))
      self.git_tag_name = $1.gsub(/[\s:]+/, '_')
    end
    author_scan
  end

  def <=>(other)
    self.identifier <=> other.identifier
  end

  def git_commit_message
    [ ((inverted ? "UNDO: #{name}" : name) unless name =~ /^\[\w+ @ \d+\]/),
      comment,
      "darcs-hash:#{identifier}" ].compact.join("\n\n")
  end

  def self.read_from_repo(repo)
    REXML::Document.new(output_of("darcs", "changes", "--reverse", "--repodir=#{repo}", "--xml", "--summary")).get_elements('changelog/patch').map do |p|
      DarcsPatch.new(repo, p)
    end
  end

  # Return committish for corresponding patch in current git repo, or false/nil
  def id_in_git_repo
    @git_commit ||= find_in_git_repo
  end

  def pull_and_apply
    puts "\n" + ("=" * 80)
    puts "PATCH : #{name}"
    puts "DATE  : #{date}"
    puts "AUTHOR: #{author_name}"
    puts "EMAIL : #{author_email}"
    puts "=" * 80

    if id_in_git_repo
      puts "Already imported to git as #{id_in_git_repo}"
      return
    end

    pull
    system("git-status")
    apply_to_git_repo
  end

  private

  def author_scan
    @author_name, @author_email = if (author =~ /^\s*(\S.*?)\s*\<(\S+@\S+?)\>\s*$/)
                                    [$1, $2]
                                  elsif (author =~ /^\s*\<?(\S+@\S+?)\>?\s*$/)
                                    [$1.split('@').first, $1]
                                  else
                                    [author, ''] # Could manufacture or insert email address here
                                  end
  end

  def pull
    run("darcs", "pull", "--all", "--quiet", "--match", "hash #{identifier}", "--set-scripts-executable", source_repo)
    unless `darcs whatsnew -sl` =~ /^No changes!$/
      puts "Darcs reports dirty directory: assuming conflict that is fixed by a later patch... reverting"
      run("darcs revert --all")
    end
  end

  def apply_to_git_repo
    ENV['GIT_AUTHOR_NAME'] = ENV['GIT_COMMITTER_NAME'] = author_name
    ENV['GIT_AUTHOR_EMAIL'] = ENV['GIT_COMMITTER_EMAIL'] = author_email
    ENV['GIT_AUTHOR_DATE'] = ENV['GIT_COMMITTER_DATE'] = date
    if is_tag
      run("git-tag", "-a", "-m", git_commit_message, git_tag_name)
    else
      if (new_files = git_new_files).any?
        run(*(["git-add"] + new_files))
      end
      if git_changed_files.any? || new_files.any?
        run("git-commit", "-a", "-m", git_commit_message)
      end
    end
  end

  def find_in_git_repo
    return nil unless File.exists?(".git/refs/heads/master")  # empty repo
    if is_tag then
      output_of("git-tag", "-l").split(/\r?\n/).include?(git_tag_name) &&
        output_of("git-rev-list", "--max-count=1", "tags/#{git_tag_name}").strip
    else
      output_of("git-log", "-n1", "--grep=darcs-hash:#{identifier}").scan(/^commit ([a-z0-9]+$)/).flatten.first
    end
  end

  def darcs_date_to_git_date(d)
    d.gsub(/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)\d+$/, '\1-\2-\3 \4:\5')
  end

  def git_ls_files(wanted)
    output_of(*["git-ls-files", "-t", "-o", "-m", "-d", "-X", ".git/info/exclude"]).scan(/^(.?) (.*?)$/m).map do |code, name|
      name if wanted.include?(code)
    end.compact
  end
  def git_new_files() git_ls_files(["?"]) end
  def git_changed_files() git_ls_files(%w(? R C)) end
end


unless File.directory?("_darcs")
  run("darcs", "init")
  run("git-init")
  File.open(".git/info/exclude", "a") { |f| f.write("_darcs\n.DS_Store\n") }
  File.open("_darcs/prefs/boring", "a") { |f| f.write("\\.git$\n\\.DS_Store$\n") }
end


patches = DarcsPatch.read_from_repo(SRCREPO)

patches_to_pull = []
while patch = patches.pop
  break if patch.id_in_git_repo
  patches_to_pull.unshift(patch)
end

patches_to_pull.each { |patch| patch.pull_and_apply }
