#!/usr/bin/env ruby
##
## Author: Steve Purcell, http://www.sanityinc.com/
## Obtain the latest version of this software here: http://git.sanityinc.com/
##

# XXX: make backwards compatible
# TODO: import parallel darcs repos as git branches, identifying branch points
# TODO: use default repo if none was supplied

require 'ostruct'
require 'rexml/document'
require 'optparse'
require 'yaml'

# Explicitly setting a time zone would cause darcs to only output in
# that timezone hence we couldn't get the actual patch TZ
# ENV['TZ'] = 'GMT0'

GIT_PATCHES = ".git/darcs_patches"
DEFAULT_AUTHOR_MAP_FILE = ".git/darcs_author_substitutions"

# -------------------------------------------------------------------------------
# Usage info and argument parsing
# -------------------------------------------------------------------------------

OPTIONS = { :default_email => nil,
            :list_authors  => false,
            :author_map    => nil,
            :num_patches   => 0 }
opts = OptionParser.new do |opts|
  opts.banner = <<-end_usage
Creates git repositories from darcs repositories

  usage: darcs-to-git DARCSREPODIR [options]


1. Create an *empty* directory that will become the new git repository
2. From inside that directory, run this program, passing the location
   of the local source darcs repo as a parameter

The program will git-init the empty directory, and migrate all patches
in the source darcs repo into commits in that repository.

Thereafter, incremental patch conversion from the same source repo is
possible by repeating step 2.

NOTE: In case of multiple tags, only the first one will be applied.
If you really need to, you can manually identify the patch and use 
\"git tag -f <tagname> <sha1-of-commit-before-tagging>\".

OPTIONS

  end_usage
  opts.on('--default-email ADDRESS',
          "Set the email address used when no explicit address is given") do |m|
    OPTIONS[:default_email] = m
  end
  opts.on('--list-authors',
          "List all unique authors in source repo and quit.") do |m|
    OPTIONS[:list_authors] = m
  end
  opts.on('--author-map FILE',
          "Supply a YAML file that maps committer names to canonical author names") do |f|
    OPTIONS[:author_map] = f
  end
  opts.on('--patches [N]', OptionParser::DecimalInteger,
          "Only pull N patches.") do |n|
    OPTIONS[:num_patches] = n
  end
end
opts.parse!

SRCREPO = ARGV[0]
if SRCREPO.nil?
  abort opts.banner() + opts.summarize()
elsif !FileTest.exists?(SRCREPO + '/_darcs')
  abort "#{SRCREPO} is not a valid local darcs repository"
end


# -------------------------------------------------------------------------------
# Utilities
# -------------------------------------------------------------------------------
def run(*args)
  puts "Running: #{args.inspect}"
  system(*args) || raise("Failed to run: #{args.inspect}")
end

def output_of(*args)
  puts "Running: #{args.inspect}"
  output = IO.popen(args.map {|a| "'#{a}'"}.join(' '), 'r') { |p| p.read }
  if $?.exitstatus == 0
    return output
  else
    raise "Failed to run: #{args.inspect}"
  end
end

class Symbol
  def to_proc() lambda { |o| o.send(self) } end
end

class String
  def darcs_unescape
    # darcs uses '[_\hh_]' to quote non-ascii characters where 'h' is
    # a hexadecimal.  We translate this to '=hh' and use ruby's unpack
    # to do replace this with the proper byte.
    gsub(/\[\_\\(..)\_\]/) { |x| "=#{$1}" }.unpack("M*")[0]
  end
end


# -------------------------------------------------------------------------------
# Map darcs authors to git authors
# -------------------------------------------------------------------------------
class AuthorMap < Hash
  attr_accessor :default_email

  def self.load(filename)
    new.merge(YAML.load_file(filename))
  end

  # gives the name and email
  def [](author)
    name_and_email(super || author)
  end

  private

  def name_and_email(author)
    if (author =~ /^\s*(\S.*?)\s*\<(\S+@\S+?)\>\s*$/)
      [$1, $2]
    elsif (author =~ /^\s*\<?(\S+@\S+?)\>?\s*$/)
      email = $1
      [email.split('@').first, email]
    else
      [author, default_email]
    end
  end
end

# -------------------------------------------------------------------------------
# Storing a history of related darcs and git commits
# -------------------------------------------------------------------------------

class CommitHistory
  def initialize(patch_file_name)
    @patch_file_name = patch_file_name
    @darcs_patches_in_git = YAML.load_file(patch_file_name) || {}
  end

  def record_git_commit(commit_id, identifier)
    # using one file per darcs patch would be an incredible waste of space
    # on my system one file takes up 4K even if only a few bytes are in it
    # hence we just use a simple YAML hash
    @darcs_patches_in_git[identifier] = commit_id
    File.open(@patch_file_name, File::WRONLY|File::APPEND|File::CREAT) do |f|
      f.puts "#{identifier}: #{commit_id}"
    end
  end

  def find_git_commit(is_tag, git_tag_name, identifier)
    return nil if empty_repo?
    if is_tag
      output_of("git-tag", "-l").split(/\r?\n/).include?(git_tag_name) &&
        output_of("git-rev-list", "--max-count=1", "tags/#{git_tag_name}").strip
    else
      @darcs_patches_in_git[identifier];
    end
  end

  private

  def empty_repo?
    !system("git rev-parse --verify HEAD >/dev/null 2>&1")
  end
end

# -------------------------------------------------------------------------------
# Reading darcs patches and applying them to a git repo
# -------------------------------------------------------------------------------

class DarcsPatch
  attr_accessor :source_repo, :author, :date, :inverted, :identifier, :name, :is_tag, :git_tag_name, :comment
  attr_reader :git_author_name, :git_author_email

  def initialize(source_repo, patch_xml)
    self.source_repo = source_repo
    self.author = patch_xml.attribute('author').value.darcs_unescape
    self.date = darcs_date_to_git_date(patch_xml.attribute('date').value,
                                       patch_xml.attribute('local_date').value)
    self.inverted = (patch_xml.attribute('inverted').to_s == 'True')
    self.identifier = patch_xml.attribute('hash').to_s
    self.name = patch_xml.get_elements('name').first.get_text.value.darcs_unescape rescue 'Unnamed patch'
    self.comment = patch_xml.get_elements('comment').first.get_text.value.darcs_unescape rescue nil
    if (self.is_tag = (self.name =~ /^TAG (.*)/))
      self.git_tag_name = $1.gsub(/[\s:]+/, '_')
    end
    @git_author_name, @git_author_email = AUTHOR_MAP[author]
  end

  def <=>(other)
    self.identifier <=> other.identifier
  end

  def git_commit_message
    [ ((inverted ? "UNDO: #{name}" : name) unless name =~ /^\[\w+ @ \d+\]/),
      comment
    ].compact.join("\n\n")
    #  "darcs-hash:#{identifier}" ].compact.join("\n\n")
  end

  def self.read_from_repo(repo)
    REXML::Document.new(output_of("darcs", "changes", "--reverse",
                                  "--repodir=#{repo}", "--xml",
                                  "--summary")).
      get_elements('changelog/patch').map do |p|
      DarcsPatch.new(repo, p)
    end
  end

  # Return committish for corresponding patch in current git repo, or false/nil
  def id_in_git_repo
    @git_commit ||= COMMIT_HISTORY.find_git_commit(is_tag, git_tag_name, identifier)
  end

  def pull_and_apply
    puts "\n" + ("=" * 80)
    puts "PATCH : #{name}"
    puts "DATE  : #{date}"
    puts "AUTHOR: #{author} => #{git_author_name} <#{git_author_email}>"
    puts "=" * 80

    if id_in_git_repo
      puts "Already imported to git as #{id_in_git_repo}"
      return
    end

    pull
    system("git-status")
    apply_to_git_repo
  end

  private

  def pull
    run("darcs", "pull", "--all", "--quiet",
        "--match", "hash #{identifier}",
        "--set-scripts-executable", source_repo)
    unless `darcs whatsnew -sl` =~ /^No changes!$/
      puts "Darcs reports dirty directory: assuming conflict that is fixed by a later patch... reverting"
      run("darcs revert --all")
    end
  end

  def apply_to_git_repo
    ENV['GIT_AUTHOR_NAME'] = ENV['GIT_COMMITTER_NAME'] = git_author_name
    ENV['GIT_AUTHOR_EMAIL'] = ENV['GIT_COMMITTER_EMAIL'] = git_author_email
    ENV['GIT_AUTHOR_DATE'] = ENV['GIT_COMMITTER_DATE'] = date
    if is_tag
      run("git-tag", "-a", "-m", git_commit_message, git_tag_name)
    else
      if (new_files = git_new_files).any?
        run(*(["git-add"] + new_files))
      end
      if git_changed_files.any? || new_files.any?
        run("git-commit", "-a", "-m", git_commit_message)
      end
      # get full id of last commit and associate it with the patch id
      commit_id = output_of("git-log", "-n1").scan(/^commit ([a-z0-9]+$)/).flatten.first
      COMMIT_HISTORY.record_git_commit(commit_id, identifier)
    end
  end

  def darcs_date_to_git_date(utc,local)
    # Calculates a git-friendly date (e.g., timezone CET decribed as
    # +0100) by using the two date fields that darcs gives us: a list
    # of numbers describing the UTC time and a local time formatted in
    # a human-readable format.  We could parse the local time and
    # derive the timezone offset from the timezone name. but timezones
    # aren't well-defined, so we ignore the timezone name and instead
    # calculate the timezone offset ourselves by calculating the
    # difference between local time and UTC time.
    if not utc =~ /^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/
      raise "Wrong darcs date format"
    end
    utc_time = Time.utc($1,$2,$3,$4,$5,$6)
    # example: Mon Oct  2 14:23:28 CEST 2006
    # everything except timezone name is fixed-length, if parsing
    # fails we just use UTC
    pat = /^\w\w\w (\w\w\w) ([ 1-9]\d) ([ 0-9]\d)\:(\d\d)\:(\d\d) \w* (\d\d\d\d)/
    local_time = if pat =~ local
                   Time.utc($6,$1,$2,$3,$4,$5)
                 else
                   utc_time
                 end
    offs = local_time - utc_time # time offset in seconds
    t = local_time
    # formats the above example as: 2006-10-02 14:23:28 +0200
    s = sprintf("%4d-%02d-%02d %02d:%02d:%02d %s%02d%02d",
                t.year, t.month, t.day,
                t.hour, t.min, t.sec,
                offs < 0 ? "-" : "+", offs.abs/3600, offs.abs.modulo(3600)/60 )
  end

  def git_ls_files(wanted)
    output_of(*["git-ls-files", "-t", "-o", "-m", "-d", "-X", ".git/info/exclude"]).scan(/^(.?) (.*?)$/m).map do |code, name|
      name if wanted.include?(code)
    end.compact
  end
  def git_new_files() git_ls_files(["?"]) end
  def git_changed_files() git_ls_files(%w(? R C)) end
end

def extract_authors(patches)
  unique_authors = {}
  patches.each do |p|
    unique_authors[p.author] =
      "#{p.git_author_name}" + (p.git_author_email.nil? ? "" : " <#{p.git_author_email}>")
  end
  puts "# You can use the following output as a starting point for an author_map"
  puts "# Just fill in the proper text after the colon;  put email addresses in"
  puts "# angle brackets. You can remove any lines that look OK to you."
  # TODO: Can we make the output sorted?
  puts YAML::dump( unique_authors )
end


# -------------------------------------------------------------------------------
# Pre-flight checks
# -------------------------------------------------------------------------------

def darcs_version
  output_of(*%w(darcs -v)).scan(/(\d+)\.(\d+)\.(\d+)/).flatten.map {|v| v.to_i}
end
class Array; include Comparable; end

unless darcs_version > [1, 0, 7]
  STDERR.write("WARNING: your darcs appears to be old, and may not work with this script\n")
end


# -------------------------------------------------------------------------------
# Initialise the working area
# -------------------------------------------------------------------------------

unless File.directory?("_darcs")
  run("darcs", "init")
  run("git-init")
  run("touch", "#{GIT_PATCHES}")  # TODO: CommitHistory should take care of this instead
  File.open(".git/info/exclude", "a") { |f| f.write("_darcs\n.DS_Store\n") }
  File.open("_darcs/prefs/boring", "a") { |f| f.write("\\.git$\n\\.DS_Store$\n") }
  # TODO: migrate darcs borings into git excludes?
end

unless FileTest.exists?("#{GIT_PATCHES}")
  # XXX: convert to new format
  STDERR.puts "It seems your repo has been created with an old version of #{$0}."
  exit(1)
end

AUTHOR_MAP = if OPTIONS[:author_map]
               AuthorMap.load(OPTIONS[:author_map])
             elsif File.exists?(DEFAULT_AUTHOR_MAP_FILE)
               AuthorMap.load(DEFAULT_AUTHOR_MAP_FILE)
             else
               AuthorMap.new
             end
AUTHOR_MAP.default_email = OPTIONS[:default_email]

COMMIT_HISTORY = CommitHistory.new(GIT_PATCHES)


patches = DarcsPatch.read_from_repo(SRCREPO)
if OPTIONS[:list_authors]
  extract_authors(patches)
  exit(0)
end

patches_to_pull = []
while patch = patches.pop
  next if patch.id_in_git_repo
  patches_to_pull.unshift(patch)
end

want_consistency_check = true
if OPTIONS[:num_patches] > 0
  # if we don't pull all patches, then the consistency check would
  # fail, so we simply skip it
  want_consistency_check = patches_to_pull.length <= OPTIONS[:num_patches]
  # only pull specified number of patches
  patches_to_pull = patches_to_pull.first(OPTIONS[:num_patches])
end

patches_to_pull.each &:pull_and_apply


pulled = patches_to_pull.size
if pulled == 0
  puts "\nNothing to pull."
else
  puts "\nPulled #{pulled} patch#{"es" unless pulled == 1}."
  puts "\nDarcs import successful!  You may now want to run `git gc' to
improve space usage the git repo"
end

if want_consistency_check
  puts "Comparing final state with source repo..."
  system("diff", "-ur", "-x", "_darcs", "-x", ".git", ".", SRCREPO)
  if $? != 0
    abort <<-end_msg
!!! There were differences!  See diff above for details.
!!! It may be that the source repository was dirty.
!!! Run "cd #{SRCREPO} && darcs whatsnew -sl" to check.
    end_msg
  end
end
